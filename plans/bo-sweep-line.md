# 方案：Bentley–Ottmann（含退化）+ trace.json 回放

用 Rust 实现一个**确定性**扫描线（Bentley–Ottmann）算法：输入为 `f64 ∈ [-1, 1]` 的线段集合，枚举所有**点交**（包含端点接触），并输出可供 TS 前端逐步回放的 `trace.json`。第一阶段只做点交；第二阶段再加入“最大重叠线段集合”的输出。

## 范围
- 包含（第一阶段）
  - 枚举点交（内部相交 + 端点接触），并标注交点类型以便前端用不同颜色区分。
  - 预处理并告警：过滤零长度线段；对完全重复线段做去重（确定性地保留一个代表）。
  - 事件顺序与内部数据结构完全确定（同一输入多次运行结果一致）。
  - 记录 `trace.json`：事件、活动集合顺序、检查过程、确认的交点、告警信息。
- 不包含（第一阶段）
  - 不做“无需量化也完全精确”的任意浮点几何鲁棒性。
  - 不引入第三方大整数/精确谓词库（只用标准库）。
  - 不对最终交点输出做全局去重或排序（由调用方自行处理）。

## 已确定的关键决策
- 输入坐标为 `f64`，范围 `[-1, 1]`。
- 先用固定点量化：比例 `1e9`，存储用 `i64`，几何计算用 `i128`。
- 垂直线段很常见：从一开始就作为一等公民处理（而不是补丁）。
- 最终交点输出不要求全局去重/排序。

## 待办
[ ] 定义核心类型（`SegmentId`、`PointI64`、`PointRat`、`Intersection`、`IntersectionKind`）与确定性的 ID 分配规则。

[ ] 预处理阶段：
  - 零长度线段（量化后 `p0 == p1`）过滤并告警。
  - 端点规范化（例如按 `(x,y)` 字典序排序端点），使“反向同一线段”可合并。
  - 检测完全重复线段并去重（告警，保留一个代表）。

[ ] 在固定点上实现精确谓词（std-only）：
  - `orient(a,b,c)`：用 `i128` 叉积。
  - `on_segment(a,b,p)` 与包围盒判断：纯整数比较。
  - 点交分类：
    - 真交（内部–内部）
    - 端点接触（端点–端点、端点–内部）
    - 共线情况先不输出“无限交点”，留到第二阶段输出重叠线段。

[ ] 定义交点的有理数表示（std-only）：
  - 交点坐标以 `i128` 的 `num/den` 表示，并用 `gcd` 约分，保证稳定相等性判断。
  - 有理数主要用于事件排序与 trace；渲染阶段再转 `f64`（只影响像素，不影响逻辑）。

[ ] 构建确定性的事件队列：
  - 事件类型：线段起点、线段终点、交点事件。
  - 全序键：`(x, y, 类型优先级, 线段ID...)`（`x,y` 用有理数/量化坐标）。
  - 同一 `(x,y)` 的事件必须批处理，稳定处理多线同点相交。

[ ] 实现扫描线状态结构（确定性的平衡结构）：
  - 避免 `BTreeSet`（比较器依赖动态 `sweep_x` 会破坏集合不变式）。
  - 用确定性的 Treap/Skiplist：优先级由 `SegmentId` 推导（不使用 RNG），键为“在 `sweep_x`（或 `sweep_x+ε`）处的垂直顺序 + `SegmentId` 兜底”。
  - 保证在给定 `sweep_x` 下比较关系是严格全序。

[ ] 垂直线段专门路径（第一阶段必做）：
  - 在 `x = x0` 事件处，对每条垂直线段 `[ymin,ymax]`，对活动集合做区间查询：找出所有在 `x0` 处落入该 y 区间的线段并输出交点。
  - 垂直–垂直：可能无交、点交（端点接触）、或重叠（第二阶段）。
  - 将这些查询与命中都写入 trace，保证“可自圆其说”。

[ ] `trace.json` 记录契约：
  - 每一步记录：当前事件点、扫描线位置、活动集合顺序（线段 ID 列表）、操作（插入/删除/交换）、邻居检查与/或区间检查、发现并确认的交点、告警。
  - 保证 trace 生成不依赖哈希迭代顺序、不使用随机数，从而可复现。

[ ] 测试（以确定性与退化为核心）：
  - 多条线段同点相交。
  - 端点接触 vs 真交分类正确。
  - 大量垂直线段与非垂直线段的交点枚举。
  - 重复线段与零长度过滤的告警与结果稳定性。
  - “同一输入多次运行 -> trace 字节级一致”（如果实现上能保证 JSON 输出稳定序）。

## 第二阶段：共线重叠线段（最大重叠段）
[ ] 按“支撑直线”的归一化表示对共线线段分组（基于固定点端点构造稳定 key）。
[ ] 对每组做 1D 投影（非垂直用 `x`，垂直用 `y`），扫描覆盖次数；输出覆盖≥2 的**最大连续区间**作为“最大重叠线段集合”。
[ ] 用“原子不重叠子段”替换原始重叠输入，再跑点交扫描线，避免 overlap 扰动 BO 的事件逻辑。
[ ] 扩展 trace：记录重叠段输出与归并过程。

## 开放问题（不阻塞第一阶段，但会影响接口设计）
- 输入格式打算用什么（JSON/CSV/自定义），需要库 API、CLI，还是两者都要？
- 端点接触的分类需要更细吗（例如区分 `端点-端点` vs `端点-内部`），以便前端颜色更丰富？
