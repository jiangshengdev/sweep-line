# 方案：Bentley–Ottmann（含退化）+ trace.json 回放

用 Rust 实现一个**确定性**扫描线（Bentley–Ottmann）算法：输入为 `f64 ∈ [-1, 1]` 的线段集合，枚举所有**点交**（包含端点接触），并输出可供 TS 前端逐步回放的 `trace.json`。第一阶段只做点交；第二阶段再加入“最大重叠线段集合”的输出。

## 范围
- 包含（第一阶段）
  - 枚举点交（内部相交 + 端点接触），并标注交点类型以便前端用不同颜色区分。
  - 预处理并告警：过滤零长度线段；对完全重复线段做去重（确定性地保留一个代表）。
  - 事件顺序与内部数据结构完全确定（同一输入多次运行结果一致）。
  - 记录 `trace.json`：事件、活动集合顺序、检查过程、确认的交点、告警信息。
- 不包含（第一阶段）
  - 不做“无需量化也完全精确”的任意浮点几何鲁棒性。
  - 不引入第三方大整数/精确谓词库（只用标准库）。
  - 不对最终交点输出做全局去重或排序（由调用方自行处理）。

## 已确定的关键决策
- 输入坐标为 `f64`，范围 `[-1, 1]`。
- 先用固定点量化：比例 `1e9`，存储用 `i64`，几何计算用 `i128`。
- 垂直线段很常见：从一开始就作为一等公民处理（而不是补丁）。
- 最终交点输出不要求全局去重/排序。
- 扫描线状态结构不持有几何数据：树内只存 `SegmentId`，几何信息通过外部只读段表访问（优先 `&[Segment]` / `&Segments`；如需去掉生命周期可用 `Arc<[Segment]>`）。
- 内部排序优先使用有理数：事件队列的 `(x,y)`、以及比较线段在 `sweep_x` 处的 `y(sweep_x)`，均用 `i128` 的 `num/den` 表示并约分，避免浮点误差导致的不稳定。
- `trace.json` 第一版不引入依赖：手写最小 JSON，固定字段顺序与数组输出顺序，避免 `HashMap` 迭代导致的非确定性。

## 待办
[x] 定义核心类型（`SegmentId`、`PointI64`、`PointRat`、`SegmentIntersection`、`PointIntersectionKind`）与确定性的 ID 分配规则。

[x] 实现固定点量化：`f64 -> i64`（比例 `1e9`，`round`，拒绝非有限值与超出 `[-1,1]` 的输入）。

[x] 预处理阶段：
  - 零长度线段（量化后 `p0 == p1`）过滤并告警。
  - 端点规范化（例如按 `(x,y)` 字典序排序端点），使“反向同一线段”可合并。
  - 检测完全重复线段并去重（告警，保留一个代表）。

[x] 在固定点上实现精确谓词（std-only）：
  - [x] `orient(a,b,c)`：用 `i128` 叉积。
  - [x] `on_segment(a,b,p)` 与包围盒判断：纯整数比较。
  - [x] 点交分类：真交（内部–内部）、端点接触（端点–端点、端点–内部）；共线重叠用 `CollinearOverlap` 占位，第二阶段再输出“最大重叠段集合”。

[x] 定义交点的有理数表示（std-only）：
  - [x] 实现基础 `Rational(num/den)`：`i128` 表示并用 `gcd` 约分，支持稳定相等性与比较。
  - [x] 定义交点坐标（例如 `PointRat`）并用于事件排序与 trace；渲染阶段再转 `f64`（只影响像素，不影响逻辑）。

[x] 构建确定性的事件队列：
  - 事件类型：线段起点、线段终点、交点事件。
  - 全序键：`(x, y, 类型优先级, 线段ID...)`（`x,y` 用有理数/量化坐标）。
  - 同一 `(x,y)` 的事件必须批处理，稳定处理多线同点相交。

[x] 实现扫描线状态结构（确定性的平衡结构）：
  - 避免 `BTreeSet`（比较器依赖动态 `sweep_x` 会破坏集合不变式）。
  - 用确定性的 Treap/Skiplist：优先级由 `SegmentId` 推导（不使用 RNG），键为“在 `sweep_x`（或 `sweep_x+ε`）处的垂直顺序 + `SegmentId` 兜底”。
  - 保证在给定 `sweep_x` 下比较关系是严格全序。

[x] 实现第一阶段 Bentley–Ottmann 主流程（先覆盖非垂直线段）：
  - 初始化端点事件（`SegmentStart/SegmentEnd`）。
  - 事件点批处理：维护活动集合；检查相邻对并调度交点事件；输出点交记录（包含端点接触的基础覆盖）。
  - 共线重叠只做占位/告警，不在第一阶段输出“重叠段”。

[x] 垂直线段专门路径（第一阶段必做）：
  - 在 `x = x0` 事件处，对每条垂直线段 `[ymin,ymax]`，对活动集合做区间查询：找出所有在 `x0` 处落入该 y 区间的线段并输出交点。
  - 垂直–垂直：可能无交、点交（端点接触）、或重叠（第二阶段）。
  - trace 记录会在后续 `trace.json` 记录契约步骤里统一补齐。

[x] 定义 trace 数据结构与最小 JSON 输出：
  - 手写最小 JSON（不引入依赖），固定字段顺序与数组顺序。
  - 数值输出以稳定为先：`Rational` 用 `num/den`（字符串）表示，避免 JS 精度问题。

[x] 在 BO 主流程中记录 trace（最小版，第一阶段）：
  - 每一步记录：当前事件点、扫描线位置、活动集合顺序（线段 ID 列表）、本批新增交点。
  - 记录垂直线段的 x 批末 `range_by_y` 查询步骤与命中交点（作为独立 step）。

[ ] 扩展 trace 细节（第一阶段）：
  - 追加：操作（插入/删除/重排）的逐条记录、邻居检查与调度交点事件的原因、以及告警归集。

[x] 测试：trace 字节级一致（同输入多次运行）。
[x] 测试：端点接触 vs 真交分类正确（基础覆盖）。
[x] 测试：垂直线段与非垂直线段的交点枚举（基础覆盖）。
[x] 测试：重复线段与零长度过滤的告警与结果稳定性（基础覆盖）。
[ ] 测试：多条线段同点相交（退化）。
[ ] 测试：大量垂直线段压力与稳定性。

## 第二阶段：共线重叠线段（最大重叠段）
[ ] 按“支撑直线”的归一化表示对共线线段分组（基于固定点端点构造稳定 key）。
[ ] 对每组做 1D 投影（非垂直用 `x`，垂直用 `y`），扫描覆盖次数；输出覆盖≥2 的**最大连续区间**作为“最大重叠线段集合”。
[ ] 用“原子不重叠子段”替换原始重叠输入，再跑点交扫描线，避免 overlap 扰动 BO 的事件逻辑。
[ ] 扩展 trace：记录重叠段输出与归并过程。

## 开放问题（不阻塞第一阶段，但会影响接口设计）
- 输入格式打算用什么（JSON/CSV/自定义），需要库 API、CLI，还是两者都要？
- 端点接触的分类需要更细吗（例如区分 `端点-端点` vs `端点-内部`），以便前端颜色更丰富？

## 风险点与注意事项（稳定性优先）
- 溢出与 panic：当前部分有理数计算使用 `checked_* + expect`（例如 `src/sweep/segment_order.rs`），一旦后续交点坐标分子/分母增长过快可能触发 panic；需要在交点计算阶段尽量约分/控制中间量，必要时把溢出变成可返回的错误并写入告警/trace。
- 量化副作用：去重与零长度判断发生在量化后坐标上；不同的原始浮点输入可能量化到同一条线段而被视为重复（稳定但可能“意外”），需要在告警里明确说明是“量化后重复”。
- 同点批处理语义：事件队列目前已做到稳定排序，但“同一点内的事件处理优先级”需要与 `x+ε` 的状态更新规则完全一致；后续实现 BO 主流程时可能需要调整优先级与批处理步骤（保持 trace 可自圆其说）。
- `set_sweep_x` 的使用契约：状态结构排序依赖 `sweep_x`（且采用 `x+ε` 语义）。实现 BO 主流程时，需要在切到新事件点 `x` 前先把该点会发生变化的线段（起/止/交点相关）从状态结构移除，再设置 `sweep_x=x` 并通过 `reorder/insert` 恢复 `x+ε` 顺序；否则比较器变化会破坏树的不变式，导致 `pred/succ/range_by_y` 结果不可靠。
- 垂直线段路径：垂直线段不入状态结构会显著提升稳定性，但要求状态结构提供高效、确定性的 `range_by_y` 迭代；否则垂直线段多时性能会成为瓶颈。
- `range_by_y` 的复杂度：当前实现是 `lower_bound_by_y + succ` 迭代（Treap 的 `succ` 最坏 `O(log n)`），整体为 `O(log n + m log n)`；若垂直线段占比很高，后续可引入“游标/迭代器”把后续步进降到 `O(1)` 摊还，或用额外索引优化。
- Treap 的最坏情况：优先级虽确定性且分布良好，但仍可能被构造出退化高度；若担心对抗性输入，可改用“优先级来自端点稳定哈希”的版本，或实现更强平衡结构（代价更高）。
- 共线重叠：在 phase 1 用 `SegmentId` 兜底只保证“全序稳定”，不保证几何语义完整；必须按 phase 2 的“最大重叠段输出 + 原子子段替换”方案处理，避免 BO 主流程阶段出现不可自洽的情况。
