# 计划：BO 退化处理（U/L/C(p) 批处理语义）

目标：用更标准的 Bentley–Ottmann 事件点批处理方式（集合 `U(p)/L(p)/C(p)`）修复当前 `Status(SegmentNotFound)` 等退化错误，并让 trace 语义更自洽、便于回放与定位。

背景：当前实现会把 `EndpointTouch` 也调度为 `Intersection` 事件；而同点批处理里 `SegmentEnd` 先于 `Intersection`，导致“交点落在端点”时重排尝试移除已删除线段，从而触发 `SegmentNotFound`。详见 `plans/bo-sweep-line.md` 的“已知问题”章节。

## 范围
- In：
  - 第一阶段（点交，包含端点接触）的事件点处理重构：引入 `U(p)/L(p)/C(p)` 语义。
  - 修复示例生成器 `pnpm gen:sessions` 的随机用例崩溃（让 `viewer/generated/index.json` 可稳定生成）。
  - 增加回归测试覆盖：字节级稳定 + 退化复现用例不再报错。
  - trace 输出与前端回放保持兼容（不改 schema，仅可能新增/调整 notes 文案）。
- Out：
  - 第二阶段“共线重叠最大重叠段集合”（仍在 phase2 计划里做）。
  - 前端性能优化（另见 trace viewer 计划）。

## 方案要点（语义）
在每个事件点 `p`：
- `U(p)`：在 `p` 开始的线段集合（`SegmentStart`）。
- `L(p)`：在 `p` 结束的线段集合（`SegmentEnd`）。
- `C(p)`：穿过/相交于 `p` 的线段集合（来自交点事件；只包含需要在 `x+ε` 发生顺序变化的情况，通常是 `Proper`）。
- 处理步骤（经典形式，按 `x+ε` 语义）：
  1) 输出在 `p` 的交点（端点接触、Proper 等）。
  2) 从状态结构中删除 `L(p) ∪ C(p)`。
  3) 设置 `sweep_x = p.x`（保持批处理语义一致）。
  4) 将 `U(p) ∪ C(p)` 按 `x+ε` 顺序插入状态结构（可通过“先 remove 再 insert”的方式统一重排）。
  5) 在状态结构中寻找 `U(p) ∪ C(p)` 的上下邻居，调度未来交点（只调度“真正需要未来重排”的交点）。

说明：
- 端点接触（`EndpointTouch`）通常不应触发重排；更标准的做法是把它当作“在点上输出的交点”，而不是“会导致顺序翻转的交点事件”。
- 垂直线段维持“状态结构外处理”的既有策略，但要把其纳入 `U/L`（同一 x 点内一次性处理垂直命中 + 端点接触），避免与 `VerticalFlush`/批处理产生重复或遗漏。

## 实施清单
[x] 明确 `Intersection` 事件的定义：仅代表“需要在 `x+ε` 重排”的交点（优先只调度 `Proper`）。
[ ] 为事件点 `p` 构建 `U/L/C`（从批内事件列表提取并去重），并把现有“顺序逐条处理”重构为“集合批处理”。
[ ] 调整端点接触输出路径：用 `record_endpoint_pairs`（以及必要的“端点落在另一线段内部”的检测）在 `p` 输出，不再把 `EndpointTouch` 调度为 `Intersection`。
[ ] 整理垂直线段处理：在同一 `x` 批内，先输出垂直命中与垂直相关端点接触；避免依赖“跨点 flush”才能输出的语义裂缝。
[ ] 更新 trace 的 notes/events 约定（保持 schema 不变）：让 notes 能解释 `U/L/C` 的批处理过程，便于回放定位。
[ ] 增加回归测试：包含 `Status(SegmentNotFound)` 的固定复现输入（可从 seed 用例固化为明确线段集合）。
[ ] 重新跑稳定性测试：trace/session JSON 字节级一致；并确保 `pnpm gen:sessions` 默认参数可成功生成（随机用例不崩溃）。
[ ] 评估性能影响：`U/L/C` 批处理不会显著拉低大输入性能；必要时只在退化点启用额外检查（但保持确定性）。

## 风险与取舍
- 事件点语义重构会触及多个模块（事件队列、状态结构使用契约、trace），需要较多回归测试保护。
- 垂直线段与退化（同点多段）组合复杂，建议先从“修复 SegmentNotFound + 保持现有 vertical flush 行为”落地，再逐步把垂直逻辑并入 `U/L` 批处理以减少重复路径。
