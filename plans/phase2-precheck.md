# Phase 2 前置确认清单：共线重叠（最大重叠段）+ 同点相交语义

目的：在开始 `## 第二阶段：共线重叠线段（最大重叠段）`（见 `plans/bo-sweep-line.md`）之前，把关键语义与输出契约先定下来，避免实现到一半因为“输出含义/规模/溯源”不同而返工。

## 现状（Phase 1 已实现）
- 点交枚举已实现（含 `Proper` / `EndpointTouch`），并提供 `trace.v1` 与 `session.v1` 稳定输出：
  - 入口：`src/run.rs` 的 `run_phase1`
  - BO 主流程：`src/sweep/bo.rs`
- 共线重叠当前仅占位：`intersect_segments` 返回 `CollinearOverlap`，并在 phase1 记录 notes，不输出“重叠段”：
  - `src/geom/intersection.rs`：`SegmentIntersection::CollinearOverlap`
  - `src/sweep/bo.rs`：`Check(a,b) -> CollinearOverlap(phase2)`

## 需要在开始 Phase 2 前确认的问题（建议逐条定结论）

### 1) “最大重叠段集合”到底指什么
- [x] 选项 A：输出“覆盖次数 ≥ 2 的所有**极大连续区间**”（按包含关系极大，区间两端都不能再延伸仍保持覆盖≥2）。
- [ ] 选项 B：输出“覆盖次数达到**全局最大值**的区间”（例如最大覆盖为 5，则只输出覆盖=5 的区间）。
- [ ] 选项 C：输出“长度最大”的重叠区间（可能多个并列）。
- 结论：采用选项 A；选项 B/C 不作为本项目“最大重叠段集合”的定义（如未来需要可作为额外查询能力）。
- [x] 裁判例子（3 条共线线段，产生 2 段覆盖次数不同的“原子子段”）：
  - 线段：`s1=[0,8]`，`s2=[2,8]`，`s3=[6,12]`（同一直线、闭区间）。
  - 覆盖次数 `c(x)`：在 `x∈[2,6)` 上 `c(x)=2`；在 `x∈[6,8]` 上 `c(x)=3`（全局最大）。
  - 选项 A 输出：`[2,8]`（覆盖≥2 的极大连续区间）。
  - 选项 B 输出：`[6,8]`（覆盖达到全局最大 3 的区间）。
  - 备注：这里的“两段”指投影后按端点切分得到的覆盖常值子段；选项 A 会把它们合并成一个更大的极大区间。

### 2) 重叠/端点的边界语义（闭区间 vs 开区间）
- [x] 重叠是否要求“长度 > 0”（仅端点相同是否也算重叠）？
  - 结论：不要求；**仅端点相同也算重叠**，但输出上需与“长度>0 的重叠段”区分（例如输出为“重叠点”/退化区间）。
  - 现状：`src/geom/intersection.rs` 的 `CollinearOverlap` 仍按“长度>0 才占位”实现；端点相同会在 phase1 以点交（`EndpointTouch`）输出。
- [x] 区间端点是否是闭区间（包含端点）？
  - 结论：闭区间；phase2 覆盖次数计算包含端点，因此端点接触对应的覆盖也会体现在结果中（必要时以“重叠点”单独输出）。
- [x] 点交类型是否需要把“端点接触”细分（用于前端颜色/输出契约）？
  - 结论：需要，至少区分三类：`Proper`（内部–内部）、`EndpointEndpoint`（端点–端点）、`EndpointInterior`（端点–内部）。
  - 备注：实现上可选择“扩展 enum”或“保留 `EndpointTouch` + 追加子字段”；对外输出必须可区分这三种情况。

### 3) 重复线段（duplicate）是否影响“覆盖次数”
- [x] 现状：预处理会去重（`src/preprocess.rs`），重复输入只保留一个代表并给 warning。
- [x] 结论：Phase 2 的“覆盖次数”只基于**预处理后的线段集合**计算；重复输入不作为多重覆盖（multiset）。
  - 因此：预处理后**不存在**“完全相同（含反向）”的线段（按量化后端点判等）。
  - 仍可能存在：共线的部分重叠/包含（这正是 Phase 2 要处理的重叠）。

### 4) Phase 2 输出放在哪里（接口 / schema）
- [x] 输出作为新的顶层字段（例如 `session.v2` / 新 schema），不塞进 `trace.v1` 的 `warnings/notes`。
- [x] 是否需要前端可视化 phase2 重叠段？
  - 结论：可视化不在本次任务范围内；但 phase2 输出需要为未来可视化准备足够数据。
  - 最低要求（面向 viewer/trace 的“可画 + 可追溯”）：
    - 几何：同时支持“重叠段（长度>0）”与“重叠点（仅端点接触的退化重叠）”。
    - 覆盖：能推导/展示覆盖次数信息（至少能判断该处覆盖≥2；若需要按覆盖层数上色，需提供覆盖常值的原子子段或等价信息）。
    - 溯源：每个重叠结果能映射到贡献它的**预处理后**线段集合（`SegmentId` 列表或可压缩的等价表示）。

### 5) “原子不重叠子段替换”后的溯源与 ID 规则
- [ ] Phase 2 是否会把共线重叠输入替换为“原子子段”后再跑点交扫描线？
  - 计划：`plans/bo-sweep-line.md` 已写了该思路。
- [ ] 若替换：需要明确
  - 原子子段的 ID 如何分配（确定性、稳定排序；建议不要复用 `SegmentId`，而是引入 `atomic_segment_id`）
  - 原子子段如何映射回**预处理后线段**（建议提供 `atomic_segment_id -> [SegmentId...]` 或类似结构）
  - [x] 交点对外输出：采用方案 B（信息优先）
    - phase2 的交点记录引用 `atomic_segment_id`（而非 `SegmentId` pair）
    - `session.v2` 同时提供 `atomic_segment_id -> [SegmentId...]` 溯源，viewer 可据此高亮“涉及哪些预处理后线段”

### 6) “同点多线段相交”时，交点输出是否需要“全 pair 组合”
- [ ] 选项 A（pair 语义）：若同一点 `p` 上有 `k` 条线段都包含 `p`，输出所有无序对 `{si,sj}`，共 `k*(k-1)/2` 条 `PointIntersectionRecord`。
- [x] 选项 B（point 聚合语义）：每个点只输出一次，记录“该点涉及的线段集合”，由调用方（或前端）自行展开 pairs。
- [ ] 选项 C（混合语义）：保持现有 `PointIntersectionRecord` 输出，但额外提供“按点聚合”的索引表（不破坏兼容性但会扩展 schema）。
  - 结论：选择选项 B；默认不在输出里展开 `k*(k-1)/2` 的 pair 列表（避免爆量），可视化按“点→线段集合”高亮即可。

#### 选项对比（优缺点）
- 选项 A（pair 语义）
  - 优点：
    - 调用方“开箱即用”：直接得到 `(si,sj)` 级别的相交关系（可直接构图/计数/去重）。
    - 与现有 `PointIntersectionRecord` 列表模型一致，viewer 若以“pair 列表”为主展示单元，实现更直接。
  - 缺点：
    - 输出规模在同点处是 `O(k^2)`；phase2 原子化后端点共点增多，`k` 可能显著变大，极易爆量。
    - 为了严格正确，需要在每个事件点构造完整 `S(p)` 并枚举所有 pair；这会改变 BO 的性能特征与实现复杂度。
    - 若对外语义从 `SegmentId` 转向 `atomic_segment_id`，仍可能需要把 pair 做溯源映射，进一步放大输出。
- 选项 B（point 聚合语义）
  - 优点：
    - 输出规模在同点处是 `O(k)`，更贴合扫描线的批处理结构（天然就是“一个点 + 一组线段”）。
    - 对 viewer 友好：点选交点即可高亮 `S(p)`；若只需要“哪里相交/哪些线段参与”，不必枚举全部 pair。
    - 与第 5 点“方案 B（交点引用 `atomic_segment_id`）”更一致：按点/按集合的表达更容易保持可视化所需信息且避免爆量。
  - 缺点：
    - 调用方若确实需要 `(si,sj)` 列表，需要自行展开；若 `k` 大，展开仍会爆量，只是把成本转移到了调用方/前端。
    - “交点类型（Proper/Endpoint…）”若定义在 pair 上，聚合输出需要额外信息才能无歧义复原（例如每条线段在点上是端点还是内部）。
- 选项 C（混合语义）
  - 优点：
    - 兼顾两类需求：既可提供聚合的 `S(p)`（防爆量、便于可视化），又可在可控范围内提供 pair（便于算法消费）。
    - 可做限流：默认只保证聚合输出完整；pair 输出可按点/全局设置上限或仅对小 `k` 展开。
  - 缺点：
    - schema 更复杂，且必须定义“两种视图的一致性规则”（例如 pair 是否必须完全覆盖聚合集合、pair 被限流时如何标记）。

### 7) 输出规模与性能上限（必须提前定）
- [x] 输出规模风险：pair 语义在同点处是 `O(k^2)`；phase2 原子化会显著增加共点端点与 steps，容易导致 `trace/session` 体积爆炸。
  - 已采用第 6 点的“按点聚合”避免 pair 级爆量；但 `trace.steps × active` 仍可能把 JSON 撑到不可用。
- [x] 策略：超限直接报错退出（fail-fast），不做限流/截断（避免“看似成功但数据不完整”）。
- [x] 默认硬上限（以 `session.v2` 最终 JSON 为准；任一超限即报错）：
  - `max_session_bytes = 33554432`（32 MiB）
  - `max_trace_steps = 20000`
  - `max_trace_active_entries_total = 3500000`（所有 step 的 `active.len()` 之和）
  - 错误信息需包含：实际值/上限/建议（例如降低 `GRID_N`、`SPIDER_*`、random 用例规模，或关闭 trace）。

## 同点相交的“全 pair 组合”：详细说明（用于做决策）

### 定义
同一点 `p` 上有线段集合 `S(p) = {s1..sk}`，则输出集合：
`{ (min(si,sj), max(si,sj), kind(si,sj,p), p) | i<j }`。

其中 `kind` 对每一对单独判定（用于前端上色/输出契约）：
- 若 `p` 同时是两条线段的端点：`EndpointEndpoint`（端点–端点）
- 若 `p` 是恰好一条线段的端点：`EndpointInterior`（端点–内部）
- 否则：`Proper`（内部–内部）

### 当前实现与差距
- 现状里，“端点出现在事件点”的线段会两两输出 `EndpointTouch`（这是全 pair 的一个子集）：
  - `src/sweep/bo.rs`：`record_endpoint_pairs`
- 但对于“所有线段都在该点内部相交（无端点落在 p）”的情形：
  - 经典 BO 通常只保证枚举交点“点”，并通过相邻对调度来达到正确性；
  - **不会天然保证**在同一交点把 `k*(k-1)/2` 个 pair 都输出（尤其当 `k` 很大时）。

### 选择 pair 语义的工程含义
- 需要明确：算法的“正确性目标”变成“枚举所有相交 pair”，而不是“枚举所有相交点”。
- 对同点退化：可能需要在每个事件点显式构造 `S(p)` 并输出所有 pairs（这会改变性能特征与实现复杂度）。

### 选择 point 聚合语义的工程含义
- 更贴近“事件点批处理”的真实结构（`U/L/C(p)` + 垂直命中），且能避免 `O(k^2)` 输出爆炸；
- 但需要改变/扩展 schema（当前 `trace.v1`/viewer 以 `PointIntersectionRecord` 列表为核心展示单元）。
